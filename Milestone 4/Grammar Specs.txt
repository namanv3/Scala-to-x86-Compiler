Expr	= RESERVED_IF LPARAN Expr RPARAN Expr
		| RESERVED_IF LPARAN Expr RPARAN Expr RESERVED_ELSE Expr
		| RESERVED_WHILE LPARAN Expr RPARAN Expr
		| RESERVED_DO Expr RESERVED_WHILE LPARAN Expr RPARAN
		| RESERVED_FOR LPARAN Enumerators RPARAN Expr
		| RESERVED_FOR LCURLYB Enumerators RCURLYB Expr
		| RESERVED_THROW Expr
		| RESERVED_RETURN
		| RESERVED_RETURN Expr
		| IDENTIFIER EQ_ASGN Expr
		| SimpleExpr DOT IDENTIFIER EQ_ASGN Expr
		| SimpleExpr1 ArgumentExprs EQ_ASGN Expr
		| PostfixExpr
		| PostfixExpr Ascription
		| PostfixExpr RESERVED_MATCH LCURLYB CaseClauses RCURLYB


Enumerators = Generator
			| Generator SEMI_COLON Generator

Generator   = Pattern1 LEFTARROW Expr 
			| Pattern1 LEFTARROW Expr SEMI_COLON Guard
			| Pattern1 LEFTARROW Expr SEMI_COLON Pattern1 EQ_ASGN Expr

Guard = RESERVED_IF PostfixExpr

PostfixExpr = InfixExpr
			| InfixExpr IDENTIFIER

InfixExpr   = PrefixExpr
			| InfixExpr IDENTIFIER InfixExpr

PrefixExpr  = SimpleExpr
			| OP_SUB SimpleExpr
			| OP_ADD SimpleExpr 
			| OP_NOT SimpleExpr

SimpleExpr  = BlockExpr
			| SimpleExpr1

SimpleExpr1 =  Literal
			|  Path
			|  `_'
			|  `(' [Exprs] `)'
			|  SimpleExpr `.' id s
			|  SimpleExpr1 ArgumentExprs

ArgumentExprs ::=  `(' [Exprs] `)'
                |  `(' [Exprs `,'] PostfixExpr `:' `_' `*' ')'
                |  [nl] BlockExpr

Exprs         ::=  Expr {`,' Expr}

BlockExpr    ::=  ‘{’ CaseClauses ‘}’
               |  ‘{’ Block ‘}’

Block        ::=  BlockStat {semi BlockStat} [ResultExpr]

ResultExpr   ::=  Expr1

# Dcl seems to match the LHS of variable/function declaration

Dcl = RESERVED_VAL ValVarDcl
	| RESERVED_VAR VarVarDcl
	| RESERVED_DEF FunDcl
	| RESERVED_TYPE TypeDcl

ValVarDcl = Ids COLON Type
	   | Ids

FunDcl = FunSig COLON Type
	   | FunSig

FunSig = IDENTIFIER ParamClause

ParamClause = LPARAN Params RPARAN
			| LPARAN RPARAN

Params = Param
	   | Param COMMA Params

Param = IDENTIFIER COLON ParamType

ParamType = Type
		  | Type OP_MULT		# Pointer, sigh
		  | RIGHTARROW Type 	# What is this? Check

TypeDcl = IDENTIFIER

# `Type` is used like:- val x : Type = ..

Type = Basic_types
	 | Array_types
	 | List_types
	 | IDENTIFIER

List_types = TYPE_LIST LSQRB Type RSQRB
			| TYPE_LIST LSQRB Type RSQRB LPARAN int RPARAN

Array_types = TYPE_ARRAY LSQRB Type RSQRB
			| TYPE_ARRAY LSQRB Type RSQRB LPARAN int RPARAN

Basic_types = TYPE_CHAR
			| TYPE_BOOL
			| TYPE_BYTE
			| TYPE_SHORT
			| TYPE_INT
			| TYPE_LONG
			| TYPE_FLOAT
			| TYPE_DOUBLE
			| TYPE_STRING
			| TYPE_UNIT
			| TYPE_ANY
			| TYPE_ANYVAL

Literal = INT_LITERAL
		| FLOAT_LITERAL
		| BOOL_LITERAL
		| CHAR_LITERAL
		| STRING_LITERAL

Ids = IDENTIFIER
	| IDENTIFIER COMMA Ids

Sep = SEMI_COLON

Epsilon = 